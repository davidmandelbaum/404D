charlie = read.csv("charlie.csv")
chocolate = read.csv("chocolate.csv")
daniel = read.csv("daniel.csv")
farfell = read.csv("farfell.csv")
baxtest = head(baxter, n = 100)
angtest = head(angie, n = 100)
chartest = head(charlie, n = 100)
choctest = head(chocolate, n = 100)
dantest = head(daniel, n = 100)
feltest = head(farfell, n = 100)
# SET VARIABLES FOR CANOGRAPHY SCORING
maxalg <- function(depth){
depth = depth/10
if (4 < depth & depth < 5){
return(2.5)
}
if (depth > 5){
return(1-(10*depth-5))
# serious penalty for too-deep compression, you could break something
}
else{
return(2.5-(2-(0.25*sqrt(depth))))
# probably not penalizing very shallow compressions steeply enough
}
}
minalg <- function(depth){
depth = depth/10
if (depth == 0){
return(1)
}
else
return(1-depth) # score decreases linearly with partial recoil
}
timealg <- function(current, last){
rate = (current - last)/100
if (0.5 < rate && rate < 0.6){
return(1)
}
if (0.3 < rate && rate < 0.8){
return(1-(2*abs(0.55-rate)))
}
else
return(0)
}
# capscore function
capscore <- function(user, start){
allmax = NULL
allmin = NULL
allscore = NULL
score = start # try 20 mmHg to start with
time <- function(i){
user[i,1]
}
depth <- function(i){
user[i,2]
}
for (i in 3:nrow(user)){
score = (score - 0.9) # set this constant to whatever
if(score > 500){
riserate = 5   # recovery rate is faster when mmHg > 10
}
if(score <= 500){
riserate = 3   # recovery rate is slower when mmHg < 10
}
if(depth(i-2) < depth(i-1) & depth(i) < depth(i-1)){
allmax = rbind(allmax, c(depth(i-1), time(i-1)))
score = score + riserate*(maxalg(depth(i-1)))    #assuming we're measuring in cm, easy change
+ riserate*(timealg(tail(allmax, n=1),
head(tail(allmax, n=2), n=1)))
}
if(depth(i-2) > depth(i-1) & depth(i) > depth(i-1)){
allmin = rbind(allmin, c(depth(i-1), time(i-1)))
score = score + (riserate*minalg(depth(i-1)))
}
#   if(score > 1250){  # whatever corresponds to a score of 25 mmHg or more
#     score = 1250  # we could also drop the score a few points to allow "rewards" for continued good compressions
#   }
if(score < 250){  # Whatever corresponds to a score of 5 mmHg or less
return("point of no return")
}
allscore <- c(allscore, score)
}
return(allscore)
#   plot(allscore)
#   return(colMeans(allmax, dims = 1))
}
plot(capscore(choctest, 400))
lines(capscore(angtest, 400), col="blue")
plot(capscore(angie, 2000))
lines(capscore(baxter, 2000), col="blue")
capscore(choctest, 400)
capscore(choctest, 2000)
plot(capscore(choctest, 2000))
plot(capscore(baxtest, 2000))
plot(capscore(choctest, 2000))
lines(capscore(angtest, 2000), col="blue")
#     # serious penalty for too-deep compression, you could break something
# TO DO
# continue tweaking algorithm numbers
# add ventilations
# allow conversion to kPa?
# import the CSV file
setwd("C:/Users/Aaron/Dropbox/code")
setwd('404')
baxter = read.csv("baxter.csv")
angie = read.csv("angie.csv")
charlie = read.csv("charlie.csv")
chocolate = read.csv("chocolate.csv")
daniel = read.csv("daniel.csv")
farfell = read.csv("farfell.csv")
baxtest = head(baxter, n = 100)
angtest = head(angie, n = 100)
chartest = head(charlie, n = 100)
choctest = head(chocolate, n = 100)
dantest = head(daniel, n = 100)
feltest = head(farfell, n = 100)
# SET VARIABLES FOR CANOGRAPHY SCORING
maxalg <- function(depth){
depth = depth/10
if (4 < depth & depth < 5){
return(2.5)
}
#   if (depth > 5){
#     return(1-(10*depth-5))
#     # serious penalty for too-deep compression, you could break something
#   }
else{
return(2.5-(2-(0.25*sqrt(depth))))
# probably not penalizing very shallow compressions steeply enough
}
}
minalg <- function(depth){
depth = depth/10
if (depth == 0){
return(1)
}
else
return(1-depth) # score decreases linearly with partial recoil
}
timealg <- function(current, last){
rate = (current - last)/100
if (0.5 < rate && rate < 0.6){
return(1)
}
if (0.3 < rate && rate < 0.8){
return(1-(2*abs(0.55-rate)))
}
else
return(0)
}
# capscore function
capscore <- function(user, start){
allmax = NULL
allmin = NULL
allscore = NULL
score = start # try 20 mmHg to start with
time <- function(i){
user[i,1]
}
depth <- function(i){
user[i,2]
}
for (i in 3:nrow(user)){
score = (score - 0.9) # set this constant to whatever
if(score > 500){
riserate = 5   # recovery rate is faster when mmHg > 10
}
if(score <= 500){
riserate = 3   # recovery rate is slower when mmHg < 10
}
if(depth(i-2) < depth(i-1) & depth(i) < depth(i-1)){
allmax = rbind(allmax, c(depth(i-1), time(i-1)))
score = score + riserate*(maxalg(depth(i-1)))    #assuming we're measuring in cm, easy change
+ riserate*(timealg(tail(allmax, n=1),
head(tail(allmax, n=2), n=1)))
}
if(depth(i-2) > depth(i-1) & depth(i) > depth(i-1)){
allmin = rbind(allmin, c(depth(i-1), time(i-1)))
score = score + (riserate*minalg(depth(i-1)))
}
#   if(score > 1250){  # whatever corresponds to a score of 25 mmHg or more
#     score = 1250  # we could also drop the score a few points to allow "rewards" for continued good compressions
#   }
if(score < 250){  # Whatever corresponds to a score of 5 mmHg or less
return("point of no return")
}
allscore <- c(allscore, score)
}
return(allscore)
#   plot(allscore)
#   return(colMeans(allmax, dims = 1))
}
#
# plot(capscore(choctest, 2000))
# lines(capscore(angtest, 2000), col="blue")
#
# plot(capscore(angie, 2000))
# lines(capscore(baxter, 2000), col="blue")
plot(capscore(choctest, 2000))
lines(capscore(angtest, 2000), col="blue")
maxalg <- function(depth){
depth = depth/10
if (4 < depth & depth < 5){
return(2.5)
}
if (depth > 5){
return(1-(10*(depth-5)))
# serious penalty for too-deep compression, you could break something
}
else{
return(2.5-(2-(0.25*sqrt(depth))))
# probably not penalizing very shallow compressions steeply enough
}
}
plot(capscore(choctest, 2000))
lines(capscore(angtest, 2000), col="blue")
plot(capscore(chocolate, 2000))
lines(capscore(angie, 2000), col="blue")
plot(capscore(choctest, 4000))
lines(capscore(angtest, 4000), col="blue")
plot(capscore(chocolate, 4000))
lines(capscore(angie, 4000), col="blue")
plot(capscore(chocolate, 6000))
lines(capscore(angie, 6000), col="blue")
plot(capscore(chocolate, 10000))
lines(capscore(angie, 10000), col="blue")
capscore(chocolate, 10000)
capscore(chocolate, 50000)
plot(capscore(chocolate, 12000))
lines(capscore(angie, 12000), col="blue")
plot(capscore(charlie, 12000))
lines(capscore(angie, 12000), col="blue")
plot(capscore(charlie, 20000))
lines(capscore(angie, 20000), col="blue")
plot(capscore(daniel, 20000))
lines(capscore(angie, 20000), col="blue")
plot(capscore(farfell, 20000))
lines(capscore(angie, 20000), col="blue")
plot(capscore(farfell, 40000))
plot(capscore(daniel, 40000))
farfell <- x[ x > 0 & x < 80]
farfell <- depth[ depth > 0 & depth < 80]
farfell <- Depth[ Depth > 0 & Depth < 80]
feltest
farfell <- farfell[ depth > 0 & depth < 80]
farfell <- farfell[ Depth > 0 & Depth < 80]
farfell <- data.frame(time, depth)
farfell <- data.frame(time, Depth)
farfell <- data.frame(time)
farfell[1]
farfell[2]
feltime <- farfell[1]
feldepth <- farfell[2]
farfell <- data.frame(feltime, feldepth)
farfell
feldepth <- feldepth[ feldepth > 0 & feldepth < 80]
feldepth
clean <- function(data){
time <- data[1]
depth <- data[2]
depth <- depth[ depth > 0 & depth < 80]
data <- data.frame[time, depth]
}
clean(farfell)
clean <- function(data){
time <- data[1]
depth <- data[2]
depth <- depth[ depth > 0 & depth < 80]
data <- data.frame(time, depth)
}
clean(farfell)
clean <- function(data){
time <- data[1]
depth <- data[2]
depth <- depth[ depth > 0 & depth < 80]
time <- head(time, n = length(depth))
data <- data.frame(time, depth)
}
clean(farfell)
plot(capscore(clean(farfell))
)
capscore(clean(farfell), 5000)
plot(capscore(clean(daniel), 5000))
lines(capscore(angie), 5000)
lines(capscore(angie, 5000))
# TO DO
# continue tweaking algorithm numbers
# add ventilations
# Search for influence of airflow on ETCO2, translate rate/depth into airflow and then airflow into ETCO2?
# Search for more papers to set better parameters
# import the CSV file
setwd("C:/Users/Aaron/Dropbox/code")
setwd('404')
baxter = read.csv("baxter.csv")
angie = read.csv("angie.csv")
charlie = read.csv("charlie.csv")
chocolate = read.csv("chocolate.csv")
daniel = read.csv("daniel.csv")
farfell = read.csv("farfell.csv")
# CLEAN THE DATASET
test <- function(data){
data <- head(data, n = 100)
}
clean <- function(data){
time <- data[1]
depth <- data[2]
depth <- depth[ depth > 0 & depth < 80]
time <- head(time, n = length(depth))
data <- data.frame(time, depth)
}
# SET VARIABLES FOR CANOGRAPHY SCORING
maxalg <- function(depth){
depth = depth/10
if (4 < depth & depth < 5){
return(2.5)
}
if (depth > 5){
return(2.5-(10*(depth-5)))
# serious penalty for too-deep compression, you could break something
}
else{
return(2.5-(2-(0.25*sqrt(depth))))
# probably not penalizing very shallow compressions steeply enough
}
}
minalg <- function(depth){
depth = depth/10
if (depth == 0){
return(1)
}
else
return(1-depth) # score decreases linearly with partial recoil
}
timealg <- function(current, last){
rate = (current - last)/100
if (0.5 < rate && rate < 0.6){
return(1)
}
if (0.3 < rate && rate < 0.8){
return(1-(2*abs(0.55-rate)))
}
else
return(0)
}
# capscore function
capscore <- function(user, start){
allmax = NULL
allmin = NULL
allscore = NULL
score = start # try 20 mmHg to start with
time <- function(i){
user[i,1]
}
depth <- function(i){
user[i,2]
}
for (i in 3:nrow(user)){
score = (score - 0.9) # set this constant to whatever
if(score > 500){
riserate = 5   # recovery rate is faster when mmHg > 10
}
if(score <= 500){
riserate = 3   # recovery rate is slower when mmHg < 10
}
if(depth(i-2) < depth(i-1) & depth(i) < depth(i-1)){
allmax = rbind(allmax, c(depth(i-1), time(i-1)))
score = score + riserate*(maxalg(depth(i-1)))    #assuming we're measuring in cm, easy change
+ riserate*(timealg(tail(allmax, n=1),
head(tail(allmax, n=2), n=1)))
}
if(depth(i-2) > depth(i-1) & depth(i) > depth(i-1)){
allmin = rbind(allmin, c(depth(i-1), time(i-1)))
score = score + (riserate*minalg(depth(i-1)))
}
#   if(score > 1250){  # whatever corresponds to a score of 25 mmHg or more
#     score = 1250  # we could also drop the score a few points to allow "rewards" for continued good compressions
#   }
if(score < 250){  # Whatever corresponds to a score of 5 mmHg or less
return("point of no return")
}
allscore <- c(allscore, score)
}
return(allscore)
#   plot(allscore)
#   return(colMeans(allmax, dims = 1))
}
#
# plot(capscore(choctest, 2000))
# lines(capscore(angtest, 2000), col="blue")
#
# plot(capscore(angie, 2000))
# lines(capscore(baxter, 2000), col="blue")
plot(capscore(clean(daniel), 5000))
plot(capscore(test(daniel)), 1000)
plot(capscore(test(daniel), 1000)
)
lines(capscore(test(baxter), 1000))
bestraterange = c(0.5, 0.6)
max(bestraterange)
# TO DO
# continue tweaking algorithm numbers
# add ventilations
# Search for influence of airflow on ETCO2, translate rate/depth into airflow and then airflow into ETCO2?
# Search for more papers to set better parameters
# what should the max depth be?
# IMPORT THE CSV FILE
setwd("C:/Users/Aaron/Dropbox/code")
setwd('404')
baxter = read.csv("baxter.csv")
angie = read.csv("angie.csv")
charlie = read.csv("charlie.csv")
chocolate = read.csv("chocolate.csv")
daniel = read.csv("daniel.csv")
farfell = read.csv("farfell.csv")
# CLEAN THE DATASET
test <- function(data){
data <- head(data, n = 100)
}
clean <- function(data){
time <- data[1]
depth <- data[2]
depth <- depth[ depth > 0 & depth < 80]
time <- head(time, n = length(depth))
data <- data.frame(time, depth)
}
# SET VARIABLES FOR CANOGRAPHY SCORING
mindepth = 4.5
maxdepth = 5.5
depthscore = 2.5
maxalg <- function(depth){
depth = depth/10
if (mindepth < depth & depth < maxdepth){
return(depthscore)
}
if (depth > maxdepth){
return(depthscore-(10*(depth-maxdepth)))
# serious penalty for too-deep compression, you could break something
}
else{
return(depthscore-(sqrt(mindepth)-(0.25*sqrt(depth))))
# probably not penalizing very shallow compressions steeply enough
}
}
minalg <- function(depth){
depth = depth/10
recoilscore = 1
if (depth == 0){
return(recoilscore)
}
else
return(recoilscore-depth) # score decreases linearly with partial recoil
}
timealg <- function(current, last){
rate = (current - last)/100
ratescore = 1
goodrates = c(0.5, 0.6)
weakrates = c(0.3, 0.8)
if (min(goodrates) < rate && rate < max(goodrates)){
return(ratescore)
}
if (min(weakrates) < rate && rate < max(weakrates)){
return(ratescore-(2*abs(mean(weakrates)-rate)))
}
else
return(0)
}
# capscore function
capscore <- function(user, start){
allmax = NULL
allmin = NULL
allscore = NULL
score = start # try 20 mmHg to start with
time <- function(i){
user[i,1]
}
depth <- function(i){
user[i,2]
}
for (i in 3:nrow(user)){
score = (score - 0.9) # set this constant to whatever
if(score > 500){
riserate = 5   # recovery rate is faster when mmHg > 10
}
if(score <= 500){
riserate = 3   # recovery rate is slower when mmHg < 10
}
if(depth(i-2) < depth(i-1) & depth(i) < depth(i-1)){
allmax = rbind(allmax, c(depth(i-1), time(i-1)))
score = score + riserate*(maxalg(depth(i-1)))    #assuming we're measuring in cm, easy change
+ riserate*(timealg(tail(allmax, n=1),
head(tail(allmax, n=2), n=1)))
}
if(depth(i-2) > depth(i-1) & depth(i) > depth(i-1)){
allmin = rbind(allmin, c(depth(i-1), time(i-1)))
score = score + (riserate*minalg(depth(i-1)))
}
#   if(score > 1250){  # whatever corresponds to a score of 25 mmHg or more
#     score = 1250  # we could also drop the score a few points to allow "rewards" for continued good compressions
#   }
if(score < 250){  # Whatever corresponds to a score of 5 mmHg or less
return("point of no return")
}
allscore <- c(allscore, score)
}
return(allscore)
#   plot(allscore)
#   return(colMeans(allmax, dims = 1))
}
plot(capscore(clean(daniel), 3000))
lines(capscore(baxter, 3000), col="blue")
lines(capscore(angie, 3000), col="red")
mindepth = 4.0
